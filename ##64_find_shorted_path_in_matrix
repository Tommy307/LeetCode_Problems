Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.

******************************************************这个算法在矩阵找最短路径中很常用******************************************************
class Solution {
public:
int minPathSum(vector<vector<int>>& grid) {
if(grid.size()==0) return 0;

    for(int i=1;i<grid.size();i++){
        grid[i][0]+=grid[i-1][0];
    }
    
     for(int i=1;i<grid[0].size();i++){
        grid[0][i]+=grid[0][i-1];
    }                                           //先将第一行和第一列一次加上上一位的值，这样就代表了平着&竖着从起点开始走的情况。
    
    for(int i=1;i<grid.size();i++){
        for(int j=1;j<grid[i].size();j++){                //然后从没走过的顶点开始遍历，然后贪心算法，每次都选择能到这一点的两个路径的较短路径。
            grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);
        }
    }

    return grid[grid.size()-1][grid[0].size()-1]; 
}
};
